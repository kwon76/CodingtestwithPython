#greedy_ex1.py
## 그리디 알고리즘 실전 문제 1 - 큰 수의 법칙##
"""
난이도 : 하
풀이 시간 : 30분
시간 제한 : 1초
메모리 제한 : 128MB
기출 : 2019 국가 교육기관 코딩 테스트

문제 : 
큰 수의 법칙 : 다양한 수로 이루어진 배열이 있을 때 주어진 수를 m번 더하여 가장 큰 수를 만드는 법칙
단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 k번을 초과하여 더해질 수 없다.
ex) [2, 4, 5, 4, 6], m = 8, k = 3 이면 6+6+6+5+6+6+6+5 = 46
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
ex) [3, 4, 3, 4, 3], m = 7, k = 2 이면 4+4+4+4+4+4+4 = 28
"""

"""
슈도 코드 작성(풀이 작성)
그리디 알고리즘은 당장 좋은 것만을 선택하는 알고리즘이다. 이를 이용하면 
1. 배열의 원소 중 가장 큰 수를 찾는다
2. 그 수를 k번 더한다
3. 그 다음 두 번째로 큰 수를 찾아서 한 번 더한다
4. m번째 전까지 2~3번을 반복한다
"""

n, m, k = map(int, input().split())
lst = list(map(int, input().split()))
max1, max2 = sorted(lst, reverse = True)[:2]
print(max1, max2)
total = 0

#반복문 구현 구조를 잘 익혀두자. 반복변수가 m이 될 때까지가 아닌, m이 0이 될 때까지 더한 만큼 m값을 차감시키는 것이 포인트인 것 같다.
while True:
  for i in range(k):
    if m == 0:
      break
    total += max1
    m -= 1
  if m == 0:
    break
  total += max2
  m -= 1

#위의 코드의 시간 복잡도는 O(m)이다. m의 크기가 커진다면 시간초과가 나므로 수학적 아이디어를 이용하여 시간 복잡도를 줄일 수 있다.
#가장 큰 수를 k번 더하고 두 번째로 큰 수를 한번 더하는 것이 한 묶음이라 친다면, m이 k+1의 배수일 경우 그 몫만큼 곱해주면 된다.
#m이 k+1에 나누어떨이지지 않을 경우, 그 나머지만큼 가장 큰 수를 더해주면 된다. 코드는 다음과 같다.
"""
count = (m // (k+1)) * k
count += m % (k+1)
total += count * max1
total += (m-count) * max2
"""
print(total)
